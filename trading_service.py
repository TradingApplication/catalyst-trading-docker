#!/usr/bin/env python3
"""
Name of Application: Catalyst Trading System
Name of file: trading_service.py  
Version: 2.1.3
Last Updated: 2025-07-12
Purpose: Trading execution service with paper trading via Alpaca

REVISION HISTORY:
v2.1.3 (2025-07-12) - CRITICAL FIX: Added missing /execute_signals endpoint
- Added /execute_signals endpoint that coordination service expects
- Fixed signal retrieval and batch execution
- Enhanced error handling for trading execution
- Improved signal processing from database

v2.1.2 (2025-07-07) - Fixed health check compatibility issues
- Fixed health check for database_utils v2.3.1 format
- Added proper Alpaca connection status checking
- Enhanced error handling for service initialization

Description of Service:
This service executes trades via Alpaca paper trading API based on signals
generated by the technical analysis service. It provides both individual
trade execution (/execute_trade) and batch signal execution (/execute_signals).

KEY FEATURES:
- Paper trading via Alpaca Markets API
- Individual and batch trade execution
- Position management and tracking
- Risk management and position sizing
- Trade record persistence
- Comprehensive error handling
"""

import os
import json
import time
import requests
import logging
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Dict, List, Optional, Any
from flask import Flask, request, jsonify
from structlog import get_logger

# Import database utilities
from database_utils import (
    get_db_connection,
    get_redis,
    health_check,
    get_pending_signals,
    insert_trade_record,
    mark_signal_executed,
    get_open_positions
)

# Handle Alpaca API import
try:
    import alpaca_trade_api as tradeapi
    ALPACA_AVAILABLE = True
except ImportError:
    ALPACA_AVAILABLE = False
    print("⚠️ Alpaca Trade API not available, using mock trading")


class TradingService:
    """
    Trading service for executing trades via Alpaca paper trading
    """
    
    def __init__(self):
        # Initialize environment
        self.setup_environment()
        
        self.app = Flask(__name__)
        self.setup_logging()
        self.setup_routes()
        
        # Initialize Redis client
        self.redis_client = get_redis()
        
        # Service URLs
        self.coordination_url = os.getenv('COORDINATION_URL', 'http://coordination-service:5000')
        
        # Trading configuration
        self.trading_config = {
            'enabled': os.getenv('TRADING_ENABLED', 'false').lower() == 'true',
            'max_position_size': float(os.getenv('MAX_POSITION_SIZE', '1000')),
            'max_daily_trades': int(os.getenv('MAX_DAILY_TRADES', '10')),
            'default_stop_loss_pct': float(os.getenv('DEFAULT_STOP_LOSS_PCT', '2.0')),
            'default_take_profit_pct': float(os.getenv('DEFAULT_TAKE_PROFIT_PCT', '4.0')),
            'min_confidence': float(os.getenv('MIN_TRADING_CONFIDENCE', '60.0'))
        }
        
        # Alpaca configuration
        self.alpaca_config = {
            'api_key': os.getenv('ALPACA_API_KEY'),
            'secret_key': os.getenv('ALPACA_SECRET_KEY'),
            'base_url': os.getenv('ALPACA_BASE_URL', 'https://paper-api.alpaca.markets'),
            'data_url': os.getenv('ALPACA_DATA_URL', 'https://data.alpaca.markets')
        }
        
        # Initialize Alpaca API
        self.alpaca = self._init_alpaca()
        
        # Trading metrics
        self.daily_metrics = {
            'trades_executed': 0,
            'total_pnl': 0.0,
            'successful_trades': 0,
            'failed_trades': 0
        }
        
        # Register with coordination
        self._register_with_coordination()
        
        self.logger.info("Trading Service v2.1.3 initialized",
                        environment=os.getenv('ENVIRONMENT', 'development'),
                        trading_enabled=self.trading_config['enabled'],
                        alpaca_connected=self.alpaca is not None)
        
    def setup_environment(self):
        """Setup environment variables and paths"""
        # Paths
        self.log_path = os.getenv('LOG_PATH', '/app/logs')
        self.data_path = os.getenv('DATA_PATH', '/app/data')
        
        # Create directories
        os.makedirs(self.log_path, exist_ok=True)
        os.makedirs(self.data_path, exist_ok=True)
        
        # Service configuration
        self.service_name = 'trading_service'
        self.port = int(os.getenv('PORT', '5005'))
        self.log_level = os.getenv('LOG_LEVEL', 'INFO')
        
    def setup_logging(self):
        """Setup structured logging"""
        self.logger = get_logger()
        self.logger = self.logger.bind(service=self.service_name)
        
    def _init_alpaca(self):
        """Initialize Alpaca API client"""
        if not ALPACA_AVAILABLE:
            self.logger.warning("Alpaca API not available, using mock trading")
            return None
            
        if not self.alpaca_config['api_key'] or not self.alpaca_config['secret_key']:
            self.logger.warning("Alpaca API credentials not configured")
            return None
            
        try:
            api = tradeapi.REST(
                key_id=self.alpaca_config['api_key'],
                secret_key=self.alpaca_config['secret_key'],
                base_url=self.alpaca_config['base_url'],
                api_version='v2'
            )
            
            # Test connection
            account = api.get_account()
            self.logger.info("Successfully connected to Alpaca API",
                           account_status=account.status,
                           buying_power=account.buying_power)
            
            return api
            
        except Exception as e:
            self.logger.error("Failed to initialize Alpaca API", error=str(e))
            return None
            
    def _check_alpaca_health(self) -> bool:
        """Check if Alpaca API is healthy"""
        if not self.alpaca:
            return False
            
        try:
            account = self.alpaca.get_account()
            return account.status == 'ACTIVE'
        except:
            return False
            
    def setup_routes(self):
        """Setup Flask routes"""
        
        @self.app.route('/health', methods=['GET'])
        def health():
            db_health = health_check()
            alpaca_health = self._check_alpaca_health()
            
            # Handle different database_utils versions
            db_status = False
            redis_status = False
            
            if 'postgresql' in db_health:
                # v2.3.1 format
                db_status = db_health['postgresql'].get('status') == 'healthy'
                redis_status = db_health['redis'].get('status') == 'healthy'
            elif 'database' in db_health:
                # older format
                db_status = db_health['database'] == 'healthy'
                redis_status = db_health['redis'] == 'healthy'
            
            overall_health = db_status and redis_status and alpaca_health
            
            return jsonify({
                "status": "healthy" if overall_health else "degraded",
                "service": "trading_service",
                "version": "2.1.3",
                "database": db_status,
                "redis": redis_status,
                "alpaca": "connected" if alpaca_health else "disconnected",
                "trading_enabled": self.trading_config['enabled'],
                "timestamp": datetime.now().isoformat()
            })
            
        @self.app.route('/execute_signals', methods=['POST'])
        def execute_signals():
            """Execute all pending signals for a trading cycle - CRITICAL FIX"""
            try:
                data = request.json or {}
                cycle_id = data.get('cycle_id')
                
                self.logger.info("Starting signal execution", cycle_id=cycle_id)
                
                # Check if trading is enabled
                if not self.trading_config['enabled']:
                    return jsonify({
                        'trades_executed': 0,
                        'message': 'Trading is disabled',
                        'cycle_id': cycle_id
                    })
                
                # Get pending signals from database
                signals = get_pending_signals(limit=10)
                
                if not signals:
                    self.logger.info("No pending signals found")
                    return jsonify({
                        'trades_executed': 0,
                        'message': 'No pending signals found',
                        'cycle_id': cycle_id
                    })
                
                self.logger.info(f"Found {len(signals)} pending signals")
                
                # Execute each signal
                results = []
                successful_trades = 0
                
                for signal in signals:
                    try:
                        # Convert database row to dictionary if needed
                        if hasattr(signal, '_asdict'):
                            signal_dict = signal._asdict()
                        elif isinstance(signal, dict):
                            signal_dict = signal
                        else:
                            signal_dict = dict(signal)
                        
                        self.logger.info("Executing signal", 
                                       symbol=signal_dict.get('symbol'),
                                       signal_type=signal_dict.get('signal_type'),
                                       confidence=signal_dict.get('confidence'))
                        
                        result = self.execute_signal(signal_dict)
                        results.append(result)
                        
                        if result.get('status') == 'success':
                            successful_trades += 1
                            # Mark signal as executed
                            if 'trade_id' in result and 'id' in signal_dict:
                                mark_signal_executed(signal_dict['id'], result['trade_id'])
                        
                    except Exception as e:
                        self.logger.error("Error executing individual signal", 
                                        signal_id=signal_dict.get('id'),
                                        error=str(e))
                        results.append({
                            'status': 'error',
                            'symbol': signal_dict.get('symbol'),
                            'reason': str(e)
                        })
                
                self.logger.info("Signal execution completed",
                               total_signals=len(signals),
                               successful_trades=successful_trades,
                               cycle_id=cycle_id)
                
                return jsonify({
                    'trades_executed': successful_trades,
                    'total_signals': len(signals),
                    'results': results,
                    'cycle_id': cycle_id,
                    'timestamp': datetime.now().isoformat()
                })
                
            except Exception as e:
                self.logger.error("Error executing signals", error=str(e))
                return jsonify({
                    'error': str(e),
                    'trades_executed': 0,
                    'cycle_id': cycle_id
                }), 500
            
        @self.app.route('/execute_trade', methods=['POST'])
        def execute_trade():
            """Execute a single trade based on signal"""
            signal = request.json
            
            if not signal or not signal.get('symbol'):
                return jsonify({'error': 'Invalid signal data'}), 400
                
            result = self.execute_signal(signal)
            return jsonify(result)
            
        @self.app.route('/positions', methods=['GET'])
        def get_positions():
            """Get current positions"""
            positions = self.get_current_positions()
            return jsonify({
                'count': len(positions),
                'positions': positions,
                'summary': self._calculate_position_summary(positions)
            })
            
        @self.app.route('/position/<symbol>', methods=['GET'])
        def get_position(symbol):
            """Get position for specific symbol"""
            position = self.get_position_details(symbol)
            if position:
                return jsonify(position)
            else:
                return jsonify({'error': f'No position found for {symbol}'}), 404
                
        @self.app.route('/close_position', methods=['POST'])
        def close_position():
            """Close a specific position"""
            data = request.json
            symbol = data.get('symbol')
            reason = data.get('reason', 'manual_close')
            
            if not symbol:
                return jsonify({'error': 'Symbol required'}), 400
                
            result = self.close_position_for_symbol(symbol, reason)
            return jsonify(result)
            
        @self.app.route('/orders', methods=['GET'])
        def get_orders():
            """Get recent orders"""
            status = request.args.get('status', 'all')
            limit = request.args.get('limit', 50, type=int)
            
            orders = self._get_orders(status, limit)
            return jsonify({
                'count': len(orders),
                'orders': orders
            })
            
        @self.app.route('/performance', methods=['GET'])
        def get_performance():
            """Get trading performance metrics"""
            period = request.args.get('period', 'today')
            metrics = self._calculate_performance_metrics(period)
            return jsonify(metrics)
            
    def execute_signal(self, signal: Dict) -> Dict:
        """Execute a trading signal"""
        try:
            symbol = signal.get('symbol')
            signal_type = signal.get('signal_type', signal.get('action', 'BUY'))
            confidence = signal.get('confidence', 0)
            
            if not symbol:
                return {
                    'status': 'error',
                    'reason': 'Missing symbol in signal'
                }
            
            # Check trading enabled
            if not self.trading_config['enabled']:
                return {
                    'status': 'rejected',
                    'reason': 'Trading disabled'
                }
            
            # Check confidence threshold
            if confidence < self.trading_config['min_confidence']:
                return {
                    'status': 'rejected',
                    'reason': f'Confidence {confidence} below threshold {self.trading_config["min_confidence"]}'
                }
            
            # Check if we already have a position
            existing_position = self.get_position_details(symbol)
            if existing_position:
                return {
                    'status': 'rejected',
                    'reason': f'Already have position in {symbol}'
                }
            
            # Calculate position size
            position_size = min(
                self.trading_config['max_position_size'],
                self.trading_config['max_position_size'] * (confidence / 100)
            )
            
            # Get current price
            current_price = self._get_current_price(symbol)
            if not current_price:
                return {
                    'status': 'error',
                    'reason': 'Could not get current price'
                }
                
            # Calculate shares
            shares = int(position_size / current_price)
            if shares < 1:
                return {
                    'status': 'rejected',
                    'reason': 'Position size too small'
                }
                
            # Prepare order
            order_params = self._prepare_order(
                symbol, signal_type, shares, current_price, signal
            )
            
            # Execute order
            order_result = self._execute_order(order_params)
            
            if order_result['status'] == 'success':
                # Record trade in database
                trade_record = self._create_trade_record(
                    signal, order_result['order'], order_params
                )
                trade_id = insert_trade_record(trade_record)
                
                # Update metrics
                self.daily_metrics['trades_executed'] += 1
                
                return {
                    'status': 'success',
                    'trade_id': trade_id,
                    'order_id': order_result['order_id'],
                    'symbol': symbol,
                    'direction': signal_type,
                    'shares': shares,
                    'entry_price': order_result['fill_price'],
                    'position_value': shares * order_result['fill_price']
                }
            else:
                return order_result
                
        except Exception as e:
            self.logger.error("Error executing signal",
                            symbol=signal.get('symbol'),
                            error=str(e))
            return {
                'status': 'error',
                'reason': str(e)
            }
            
    def _get_current_price(self, symbol: str) -> Optional[float]:
        """Get current price for symbol"""
        if not self.alpaca:
            # Mock price for testing
            return 100.0 + hash(symbol) % 50
            
        try:
            quote = self.alpaca.get_latest_quote(symbol)
            return float(quote.ask_price)
        except Exception as e:
            self.logger.error("Error getting current price", symbol=symbol, error=str(e))
            return None
            
    def _prepare_order(self, symbol: str, signal_type: str, shares: int, 
                      current_price: float, signal: Dict) -> Dict:
        """Prepare order parameters"""
        
        side = 'buy' if signal_type.upper() in ['BUY', 'LONG'] else 'sell'
        
        return {
            'symbol': symbol,
            'qty': shares,
            'side': side,
            'type': 'market',
            'time_in_force': 'day',
            'signal_id': signal.get('id'),
            'entry_reason': f"Signal confidence: {signal.get('confidence', 0)}%"
        }
        
    def _execute_order(self, order_params: Dict) -> Dict:
        """Execute order via Alpaca"""
        if not self.alpaca:
            # Mock execution for testing
            return {
                'status': 'success',
                'order_id': f"mock_{int(time.time())}",
                'fill_price': self._get_current_price(order_params['symbol']),
                'order': order_params
            }
            
        try:
            order = self.alpaca.submit_order(**order_params)
            
            return {
                'status': 'success',
                'order_id': order.id,
                'fill_price': float(order.filled_avg_price) if order.filled_avg_price else float(order.limit_price or 0),
                'order': order
            }
            
        except Exception as e:
            self.logger.error("Error executing order", error=str(e))
            return {
                'status': 'error',
                'reason': str(e)
            }
            
    def _create_trade_record(self, signal: Dict, order: Any, order_params: Dict) -> Dict:
        """Create trade record for database"""
        return {
            'signal_id': signal.get('id'),
            'symbol': order_params['symbol'],
            'order_id': getattr(order, 'id', f"mock_{int(time.time())}"),
            'side': order_params['side'],
            'order_type': order_params['type'],
            'quantity': order_params['qty'],
            'entry_price': getattr(order, 'filled_avg_price', self._get_current_price(order_params['symbol'])),
            'stop_loss': signal.get('stop_loss'),
            'take_profit': signal.get('take_profit'),
            'entry_reason': order_params.get('entry_reason', 'Signal execution'),
            'metadata': {
                'signal_confidence': signal.get('confidence'),
                'signal_type': signal.get('signal_type'),
                'alpaca_order_id': getattr(order, 'id', None)
            }
        }
        
    def get_current_positions(self) -> List[Dict]:
        """Get all current positions"""
        return get_open_positions()
        
    def get_position_details(self, symbol: str) -> Optional[Dict]:
        """Get position details for specific symbol"""
        positions = get_open_positions()
        for position in positions:
            if position.get('symbol') == symbol:
                return position
        return None
        
    def close_position_for_symbol(self, symbol: str, reason: str) -> Dict:
        """Close position for a specific symbol"""
        # Implementation for closing positions
        # This would involve submitting a closing order via Alpaca
        return {
            'status': 'success',
            'symbol': symbol,
            'reason': reason,
            'timestamp': datetime.now().isoformat()
        }
        
    def _calculate_position_summary(self, positions: List[Dict]) -> Dict:
        """Calculate summary metrics for positions"""
        if not positions:
            return {
                'total_positions': 0,
                'total_value': 0.0,
                'unrealized_pnl': 0.0
            }
            
        total_value = sum(float(pos.get('entry_price', 0)) * int(pos.get('quantity', 0)) 
                         for pos in positions)
        
        return {
            'total_positions': len(positions),
            'total_value': total_value,
            'unrealized_pnl': 0.0  # Would calculate based on current prices
        }
        
    def _get_orders(self, status: str, limit: int) -> List[Dict]:
        """Get orders from Alpaca"""
        if not self.alpaca:
            return []
            
        try:
            orders = self.alpaca.list_orders(status=status, limit=limit)
            return [self._serialize_order(order) for order in orders]
        except Exception as e:
            self.logger.error("Error getting orders", error=str(e))
            return []
            
    def _serialize_order(self, order) -> Dict:
        """Serialize Alpaca order object to dictionary"""
        return {
            'id': order.id,
            'symbol': order.symbol,
            'side': order.side,
            'qty': order.qty,
            'status': order.status,
            'created_at': order.created_at.isoformat() if order.created_at else None
        }
        
    def _calculate_performance_metrics(self, period: str) -> Dict:
        """Calculate performance metrics"""
        return {
            'period': period,
            'trades_executed': self.daily_metrics['trades_executed'],
            'total_pnl': self.daily_metrics['total_pnl'],
            'win_rate': 0.0,  # Would calculate from trade history
            'timestamp': datetime.now().isoformat()
        }
        
    def _register_with_coordination(self):
        """Register with coordination service"""
        try:
            response = requests.post(
                f"{self.coordination_url}/register_service",
                json={
                    'service_name': 'trading_service',
                    'service_info': {
                        'url': f"http://trading-service:{self.port}",
                        'port': self.port,
                        'version': '2.1.3',
                        'capabilities': ['trade_execution', 'position_management', 'signal_processing']
                    }
                },
                timeout=10
            )
            
            if response.status_code == 200:
                self.logger.info("Successfully registered with coordination service")
            else:
                self.logger.warning("Failed to register with coordination service",
                                  status_code=response.status_code)
                
        except requests.exceptions.RequestException as e:
            self.logger.warning("Could not register with coordination service", error=str(e))
            
    def run(self):
        """Run the service"""
        self.logger.info(f"Starting Trading Service on port {self.port}")
        self.app.run(host='0.0.0.0', port=self.port, debug=False)


if __name__ == "__main__":
    service = TradingService()
    service.run()